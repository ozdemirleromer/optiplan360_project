from __future__ import annotations

import csv
import logging
import os
import re
import shutil
import subprocess
import time
import unicodedata
from datetime import datetime
from pathlib import Path
from typing import Any

logger = logging.getLogger(__name__)

DEFAULT_ANA_DIZIN = Path(r"C:\Optiplan360_Entegrasyon")
DEFAULT_GELEN_KLASORU = "1_GELEN_SIPARISLER"
DEFAULT_ISLENEN_KLASORU = "2_ISLENEN_SIPARISLER"
DEFAULT_HATALI_KLASORU = "3_HATALI_VERILER"
DEFAULT_KURAL_DOSYASI = "ImportKurallari.opf"
DEFAULT_QUEUE_LOCK = ".optiplan_queue.lock"
FALLBACK_FIXED_RULE = Path(r"C:\Biesse\OptiPlanning\Opf\OPTIPLAN360_FIXED_12COL.opf")

CSV_ROW1 = [
    "[P_CODE_MAT]",
    "[P_LENGTH]",
    "[P_WIDTH]",
    "[P_MINQ]",
    "[P_GRAIN]",
    "[P_IDESC]",
    "[P_EDGE_MAT_UP]",
    "[P_EGDE_MAT_LO]",
    "[P_EDGE_MAT_SX]",
    "[P_EDGE_MAT_DX]",
    "[P_IIDESC]",
    "[P_DESC1]",
]

CSV_ROW2 = [
    "Material",
    "Length",
    "Width",
    "Min Q.",
    "GrainI",
    "Description",
    "Upper strip mat.",
    "Lower strip mat.",
    "Left strip mat.",
    "Right strip mat.",
    "II Description",
    "Description 1",
]
CSV_DELIMITER = ";"

RULE_TEMPLATE = (
    ";%c%n%n%m%n%c%c%c%c%c%c%c\n"
    "L=$2;W=$3;G=$5;q=$4;R=$1;D=$6;E=$11;H=$12;Y=$7;Z=$7;b=$8;c=$8;e=$9;f=$9;h=$10;i=$10;\n"
    "\n"
    "L=37500;W=18600;Q=-1;\n"
    "\n"
    "This file was generated by OptiPlanning Input Filter Editor.\n"
    "Please, do NOT modify it by hand!\n"
)

REG_KEY = r"HKCU\Software\Selco S.p.A.\OptiPlanning\1.0"


def _read_registry_value(value_name: str) -> str | None:
    proc = subprocess.run(
        ["reg", "query", REG_KEY, "/v", value_name],
        capture_output=True,
        text=True,
    )
    if proc.returncode != 0:
        return None

    for line in proc.stdout.splitlines():
        if value_name not in line:
            continue
        parts = line.split(None, 2)
        if len(parts) < 3:
            continue
        value = parts[2].strip()
        if value:
            return value
    return None


def _resolve_optiplan_exe() -> Path:
    candidates = []

    env_exe = os.environ.get("OPTIPLAN_EXE_PATH", "").strip()
    if env_exe:
        candidates.append(Path(env_exe))

    candidates.extend(
        [
            Path(r"C:\Biesse\OptiPlanning\System\OptiPlanning.exe"),
            Path(r"C:\Biesse\OptiPlanning\System\OptiPlan.exe"),
        ]
    )

    reg_path = _read_registry_value("Path")
    if reg_path:
        candidates.append(Path(reg_path))

    for exe_path in candidates:
        if exe_path.exists() and exe_path.is_file():
            return exe_path

    raise FileNotFoundError(
        "OptiPlanning exe bulunamadi. Denenen yollar: " + ", ".join(str(p) for p in candidates)
    )


def _find_rule_source() -> Path | None:
    if FALLBACK_FIXED_RULE.exists():
        return FALLBACK_FIXED_RULE

    opf_dir = _read_registry_value("OpfDir")
    if not opf_dir:
        return None

    reg_dir = Path(opf_dir)
    preferred = reg_dir / DEFAULT_KURAL_DOSYASI
    if preferred.exists():
        return preferred

    fixed = reg_dir / FALLBACK_FIXED_RULE.name
    if fixed.exists():
        return fixed

    return next(reg_dir.glob("*.opf"), None) if reg_dir.exists() else None


def _ensure_dark_factory_layout(ana_dizin: Path) -> tuple[Path, Path, Path, Path]:
    gelen_klasoru = ana_dizin / DEFAULT_GELEN_KLASORU
    islenen_klasoru = ana_dizin / DEFAULT_ISLENEN_KLASORU
    hatali_klasoru = ana_dizin / DEFAULT_HATALI_KLASORU

    for path in (gelen_klasoru, islenen_klasoru, hatali_klasoru):
        path.mkdir(parents=True, exist_ok=True)

    target_rule = ana_dizin / DEFAULT_KURAL_DOSYASI
    if not target_rule.exists():
        source_rule = _find_rule_source()
        if source_rule:
            shutil.copy2(str(source_rule), str(target_rule))
        else:
            target_rule.write_text(RULE_TEMPLATE, encoding="ascii")

    return gelen_klasoru, islenen_klasoru, hatali_klasoru, target_rule


def _normalize_grain(value: Any) -> str:
    if value is None:
        return "0"

    if isinstance(value, bool):
        return "1" if value else "0"

    if isinstance(value, (int, float)):
        return "1" if int(value) != 0 else "0"

    text = str(value).strip()
    if not text:
        return "0"

    if text in {"0", "1"}:
        return text

    match = re.search(r"\b([0-9]+)\b", text)
    if match:
        return "1" if int(match.group(1)) != 0 else "0"

    lowered = text.lower()
    if lowered in {"true", "yes", "var", "evet"}:
        return "1"
    if lowered in {"false", "no", "yok", "hayir"}:
        return "0"

    return "0"


def _normalize_quantity(value: Any) -> str:
    if value is None:
        return "1"

    if isinstance(value, bool):
        return "1" if value else "0"

    if isinstance(value, (int, float)):
        return str(max(1, int(float(value))))

    raw = str(value).strip().replace(",", ".")
    try:
        return str(max(1, int(float(raw))))
    except ValueError:
        return "1"


def _sanitize_ascii_text(value: Any) -> str:
    if value is None:
        return ""

    text = str(value)
    text = text.replace("\r", " ").replace("\n", " ").replace("\t", " ")
    text = unicodedata.normalize("NFKD", text).encode("ascii", "ignore").decode("ascii")
    text = text.replace(",", " ")
    text = re.sub(r"\s+", " ", text).strip()
    return text


def _normalize_dimension(value: Any) -> str:
    if value is None:
        return ""

    if isinstance(value, bool):
        return "1" if value else "0"

    if isinstance(value, int):
        return str(value)

    if isinstance(value, float):
        return str(int(value)) if value.is_integer() else f"{value:.3f}".rstrip("0").rstrip(".")

    text = str(value).strip().replace(",", ".")
    try:
        number = float(text)
        return str(int(number)) if number.is_integer() else f"{number:.3f}".rstrip("0").rstrip(".")
    except ValueError:
        return _sanitize_ascii_text(text)


def _sanitize_file_stem(value: str) -> str:
    safe = _sanitize_ascii_text(value)
    safe = re.sub(r"[^A-Za-z0-9._-]+", "_", safe).strip("._-")
    if safe:
        return safe
    return f"Siparis_{datetime.now().strftime('%Y%m%d_%H%M%S')}"


def _archive_file(csv_path: Path, target_dir: Path) -> Path:
    if not csv_path.exists():
        return csv_path

    destination = target_dir / csv_path.name
    if destination.exists():
        destination = target_dir / (
            f"{csv_path.stem}_{datetime.now().strftime('%Y%m%d_%H%M%S')}{csv_path.suffix}"
        )
    shutil.move(str(csv_path), str(destination))
    return destination


def _run_batch_import(csv_path: Path, rule_path: Path) -> None:
    optiplanning_exe = _resolve_optiplan_exe()
    command = [
        str(optiplanning_exe),
        "-import",
        str(csv_path),
        "-rule",
        str(rule_path),
        "-optimize",
        "-silent",
    ]

    try:
        subprocess.run(command, check=True, capture_output=True, text=True)
    except subprocess.CalledProcessError as exc:
        stderr = _sanitize_ascii_text(exc.stderr or "")
        stdout = _sanitize_ascii_text(exc.stdout or "")
        message = stderr or stdout or "OptiPlanning batch import basarisiz."
        raise RuntimeError(message) from exc


def _write_csv_file(
    dosya_adi: Path,
    parca_listesi: list[dict[str, Any]],
    baslik_satirlari: bool,
) -> None:
    with dosya_adi.open(mode="w", encoding="ascii", newline="") as dosya:
        yazici = csv.writer(dosya, delimiter=CSV_DELIMITER, lineterminator="\n")

        if baslik_satirlari:
            yazici.writerow(CSV_ROW1)
            yazici.writerow(CSV_ROW2)

        for parca in parca_listesi:
            yazici.writerow(
                [
                    _sanitize_ascii_text(parca.get("malzeme", "")),
                    _normalize_dimension(parca.get("boy", "")),
                    _normalize_dimension(parca.get("en", "")),
                    _normalize_quantity(parca.get("adet", 1)),
                    _normalize_grain(parca.get("suyolu", "0")),
                    _sanitize_ascii_text(parca.get("aciklama", "")),
                    _sanitize_ascii_text(parca.get("ust_bant", "")),
                    _sanitize_ascii_text(parca.get("alt_bant", "")),
                    _sanitize_ascii_text(parca.get("sol_bant", "")),
                    _sanitize_ascii_text(parca.get("sag_bant", "")),
                    _sanitize_ascii_text(parca.get("kod", "")),
                    _sanitize_ascii_text(parca.get("ek_aciklama", "")),
                ]
            )


def _acquire_queue_lock(lock_file: Path) -> int:
    wait_seconds = float(os.environ.get("OPTIPLAN_QUEUE_LOCK_WAIT_SEC", "180"))
    poll_seconds = float(os.environ.get("OPTIPLAN_QUEUE_LOCK_POLL_SEC", "0.2"))
    deadline = time.time() + wait_seconds

    while True:
        try:
            fd = os.open(str(lock_file), os.O_CREAT | os.O_EXCL | os.O_RDWR)
            os.write(fd, str(os.getpid()).encode("ascii", errors="ignore"))
            return fd
        except FileExistsError:
            if time.time() >= deadline:
                raise TimeoutError(f"OptiPlanning queue lock timeout: {lock_file}")
            time.sleep(poll_seconds)


def _release_queue_lock(lock_file: Path, fd: int | None) -> None:
    if fd is not None:
        try:
            os.close(fd)
        except OSError:
            pass

    try:
        lock_file.unlink(missing_ok=True)
    except OSError:
        logger.warning("Queue lock dosyasi silinemedi: %s", lock_file)


def _list_queued_csv_files(gelen_klasoru: Path) -> list[Path]:
    files = list(gelen_klasoru.glob("*.csv"))
    files.sort(key=lambda path: (path.stat().st_mtime, path.name.lower()))
    return files


def optiplan_csv_queue_path(siparis_no: str) -> Path:
    """
    Verilen siparis anahtarina gore queue'daki beklenen CSV yolunu dondurur.
    """
    ana_dizin = DEFAULT_ANA_DIZIN
    gelen_klasoru, _, _, _ = _ensure_dark_factory_layout(ana_dizin)
    dosya_stem = _sanitize_file_stem(siparis_no)
    return gelen_klasoru / f"{dosya_stem}.csv"


def optiplan_csv_dosyasi_isle(csv_path: Path | str) -> dict[str, str]:
    """
    Tek bir CSV dosyasini -silent batch import ile isler.

    Donus:
      {"source": "...", "status": "processed"|"failed", "output": "...", "error": "...?"}
    """
    source_path = Path(csv_path)
    source = str(source_path)
    ana_dizin = DEFAULT_ANA_DIZIN
    _, islenen_klasoru, hatali_klasoru, kural_dosyasi = _ensure_dark_factory_layout(ana_dizin)
    lock_file = ana_dizin / DEFAULT_QUEUE_LOCK
    lock_fd: int | None = None

    if not source_path.exists():
        raise FileNotFoundError(f"CSV dosyasi bulunamadi: {source_path}")

    try:
        lock_fd = _acquire_queue_lock(lock_file)
        try:
            _run_batch_import(source_path, kural_dosyasi)
            final_path = _archive_file(source_path, islenen_klasoru)
            logger.info("Single queue item tamamlandi: %s -> %s", source, final_path)
            return {"source": source, "status": "processed", "output": str(final_path)}
        except Exception as exc:
            failed_path = _archive_file(source_path, hatali_klasoru)
            logger.exception("Single queue item basarisiz: %s -> %s", source, failed_path)
            return {
                "source": source,
                "status": "failed",
                "output": str(failed_path),
                "error": _sanitize_ascii_text(str(exc)),
            }
    finally:
        _release_queue_lock(lock_file, lock_fd)


def optiplan_kuyrugu_isle(max_items: int | None = None) -> list[dict[str, str]]:
    """
    `1_GELEN_SIPARISLER` klasorunu FIFO sirasiyla isler.

    Her dosya icin:
    - OptiPlanning batch `-silent` import
    - Basariliysa `2_ISLENEN_SIPARISLER`
    - Hata varsa `3_HATALI_VERILER`
    """
    ana_dizin = DEFAULT_ANA_DIZIN
    gelen_klasoru, islenen_klasoru, hatali_klasoru, kural_dosyasi = _ensure_dark_factory_layout(
        ana_dizin
    )
    lock_file = ana_dizin / DEFAULT_QUEUE_LOCK
    lock_fd: int | None = None
    processed = 0
    results: list[dict[str, str]] = []

    try:
        lock_fd = _acquire_queue_lock(lock_file)

        while True:
            queued_files = _list_queued_csv_files(gelen_klasoru)
            if not queued_files:
                break

            csv_path = queued_files[0]
            source = str(csv_path)
            try:
                _run_batch_import(csv_path, kural_dosyasi)
                final_path = _archive_file(csv_path, islenen_klasoru)
                results.append({"source": source, "status": "processed", "output": str(final_path)})
                logger.info("Queue item tamamlandi: %s -> %s", source, final_path)
            except Exception as exc:
                failed_path = _archive_file(csv_path, hatali_klasoru)
                results.append(
                    {
                        "source": source,
                        "status": "failed",
                        "output": str(failed_path),
                        "error": _sanitize_ascii_text(str(exc)),
                    }
                )
                logger.exception("Queue item basarisiz: %s -> %s", source, failed_path)

            processed += 1
            if max_items is not None and processed >= max_items:
                break
    finally:
        _release_queue_lock(lock_file, lock_fd)

    return results


def optiplan_csv_otomasyon(
    siparis_no: str,
    parca_listesi: list[dict[str, Any]],
    tetikle_optiplan: bool | None = None,
    baslik_satirlari: bool = True,
) -> str:
    """
    Karanlik fabrika dizin yapisini hazirlar, ASCII CSV uretir ve
    OptiPlanning batch execution komutunu `-silent` modunda tetikler.
    """
    if tetikle_optiplan is None:
        tetikle_optiplan = os.environ.get("OPTIPLAN_ENABLE_LEGACY_CLI", "1") == "1"

    ana_dizin = DEFAULT_ANA_DIZIN
    gelen_klasoru, islenen_klasoru, hatali_klasoru, kural_dosyasi = _ensure_dark_factory_layout(
        ana_dizin
    )

    dosya_stem = _sanitize_file_stem(siparis_no)
    dosya_adi = gelen_klasoru / f"{dosya_stem}.csv"

    _write_csv_file(dosya_adi, parca_listesi, baslik_satirlari)

    logger.info("OptiPlanning CSV olusturuldu: %s", dosya_adi)
    logger.info("OptiPlanning OPF kurali hazir: %s", kural_dosyasi)

    if not tetikle_optiplan:
        logger.info("CLI tetikleme bilincli olarak pas gecildi: %s", dosya_adi.name)
        return str(dosya_adi)

    queue_results = optiplan_kuyrugu_isle()
    for item in queue_results:
        if Path(item["source"]).name != dosya_adi.name:
            continue
        if item["status"] == "processed":
            return item["output"]
        raise RuntimeError(item.get("error") or "OptiPlanning queue item failed")

    # Baska bir worker lock aldigi ve bu dosya henuz islenmedigi durumda
    logger.info("Dosya kuyruga alindi, islenme bekleniyor: %s", dosya_adi)
    return str(dosya_adi)


if __name__ == "__main__":
    ornek_siparis_verisi = [
        {
            "malzeme": "18MM 210*280",
            "boy": 2220,
            "en": 650,
            "adet": 1,
            "suyolu": "1",
            "aciklama": "MALPAK-1--Sol Yan",
            "ust_bant": "1MM",
            "alt_bant": "1MM",
            "sol_bant": "1MM",
            "sag_bant": "1MM",
            "kod": "13301002",
        }
    ]
    optiplan_csv_otomasyon(
        "Siparis_MALPAK_KILAVUZ",
        ornek_siparis_verisi,
        tetikle_optiplan=False,
        baslik_satirlari=True,
    )
